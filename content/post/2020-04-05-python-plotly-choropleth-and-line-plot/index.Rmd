---
title: Python Plotly Choropleth and Line Plot
author: Urs Wilke
date: '2020-04-05'
slug: []
categories: []
tags:
  - 'jupyter'
  - 'python'
  - 'plotly'
subtitle: ''
summary: ''
authors: []
lastmod: '2020-04-05T10:20:17+02:00'
featured: no
image:
  # https://stackoverflow.com/questions/47371794/how-to-create-an-image-preview-for-a-post-in-hugo-academic-from-rmd
  caption: ''
  focal_point: ''
  preview_only: true
projects: []
---

Maybe this should rather be a question on stackoverflow... 
The interactive plotly graph consists of two subplots (see the static image at the bottom). 
I wasn't able to couple the two subplots in a way that lasso-selecting polygons in the choropleth graph triggers the selection of the corresponding lines in the line plot (and vice versa). 
Any advice how to do that would be highly appreciated.
The ipynb file can be downloaded [here](https://github.com/urswilke/jupyter-notebooks/blob/master/plotly_choro_line.ipynb). 


Import libs:

```python
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from ipywidgets import widgets

```

Load toy geo data:

```python
%run -i 'funs.py'
df = px.data.election().reset_index()
geojson = px.data.election_geojson()

# only take ten districts:
df = df[0:11]

# correct different spelling of one district in the 2 objects:
df.loc[df['district'] == '112-DeLorimier', 'district'] = '112-De Lorimier'
# only take the polygons of the districts in df:
geojson['features'] = [feature for feature in geojson['features'] if feature['properties']['district'] in df.district.array]

```

Create toy time series data (very hacky):

```python
def create_ts_data(df):
    tag = pd.Series(np.arange(10))
    tage = pd.concat([tag] * len(df.district))
    df_ts = pd.DataFrame(df['district'].append([df['district']]*9))
    df_ts['index_orig'] = df_ts.index
    df_ts = df_ts.reset_index()
    df_ts['tag'] = tage.sort_values().array
    df_ts['randNumCol'] = df_ts['index_orig']#np.random.randint(1, 60, df_ts.shape[0])
    return(df_ts)

df_ts = create_ts_data(df)
```

Create plotly figure:

```python
# Create toy value for coloring the choropleths (actually this has to be derived from the time series data):
df['col'] = np.random.randint(1, 60, df.shape[0])

# create choropleth object:
choro = go.Choropleth(geojson      = geojson, 
                      z            = df.col,
                      locations    = df.district, 
                      featureidkey = "properties.district",
                      selected     = {'marker': {'opacity': 1}},
                      unselected   = {'marker': {'opacity': 0.3}}
                     )


# create line plot object:
linep = px.line(df_ts, x='tag', y='randNumCol', color='district')

# Create a figure with 2 subplots:
fig = make_subplots(
    rows=2, cols=1,
    row_heights=[0.7, 0.3],
    specs=[[{"type": "choropleth"}], 
            [{"type": "scatter"}]])

fig.add_trace(
    choro,
    row=1, col=1
)

for i in range(len(linep['data'])):
    fig.append_trace(linep['data'][i], col=1, row=2)
    fig.update_traces(mode='markers+lines', col=1, row=2)

fig.update_geos(fitbounds="locations", visible=False)

fw = go.FigureWidget(
    fig
)
fw.update_layout(
    dragmode='lasso', 
    hovermode='closest',
    showlegend=False)


# (comment out all the following to see how weird the subplots are coupled on selection events)

# selection events:

# choropleth is the first trace; 
# every line in line plot is an individual trace (this makes it slow):
polygons = fw.data[0]
scatter = fw.data[1:(len(df_ts)+1)]

# function to update the line width on selection 
# (it works when selecting line points, 
# when selecting polygons, not the correct lines are selected):
def update_line(trace, points, selector):
    if points.point_inds:
        trace['line']['width'] = 4
#     poly_feats = polygons.geojson['features']
#     district_names = [feature['properties']['district'] for feature in poly_feats]
#     dist_inds = district_names.index(trace['name'])
#     fw.data[0].selectedpoints = dist_inds

# try to update polygons when selecting lines, doesn't work:
def choro_update(trace, points, selector):
    if trace['name'] == 'trace 0':
        sel_inds = np.array(pd.Series([list(i['selectedpoints'] or []) for i in scatter]).astype(bool).astype(int))
        fw.data[0].selectedpoints = sel_inds

# apply select events to the figure widget
# (not sure if batch_update() changes anything):
with fw.batch_update():
    for i in range(len(scatter)):
        scatter[i].on_selection(update_line)
    polygons.on_selection(choro_update)
        
fw
```

![](feature.png)
